"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const blockchain_1 = require("./blockchain");
const prisma = new client_1.PrismaClient();
class SqlBlockchain extends blockchain_1.BlockChainBase {
    constructor() {
        super();
        this.chainSlotList = [];
        this.headerLookup = new Map();
        this.blocks = new Map();
    }
    reWrite(newChain) {
    }
    intersect(points) {
        points.reverse();
        const slotList = this.chainSlotList;
        if (slotList.length == 0 || points.length == 0) {
            return;
        }
        if (slotList[slotList.length - 1] < points[0][0]) { // our own chain is behind.
            return;
        }
        // we should have intersecton point in our cache
        if (slotList[0] >= points[0][0]) {
            let index = 0;
            while (slotList[index] < points[0][0] && index < slotList.length) {
                index++;
            }
            let queryIndex = 0;
            let matched = false;
            while (slotList[index] == points[queryIndex][0] && this.headerLookup.get(slotList[index])[0][1].compare(points[queryIndex][1]) == 0 && index < slotList.length && queryIndex < points.length) {
                index++;
                queryIndex++;
                matched = true;
            }
            if (!matched) {
                return;
            }
            queryIndex--;
            index--;
            return points[queryIndex];
        }
        else {
            let result = prisma.blockchain.findMany({
                where: {
                    slotNo: {
                        gte: points[0][0]
                    }
                },
                orderBy: {
                    slotNo: "asc"
                },
                take: points.length
            }).then(result => {
                let index = 0;
                let matched = false;
                while (points[index][0] == result[index].slotNo
                    && result[index].headerHash.compare(points[index][1]) == 0
                    && index < slotList.length
                    && index < points.length) {
                    index++;
                    matched = true;
                }
                if (matched) {
                    return [points[index - 1], result[index - 1].blockNo];
                }
                else {
                    return;
                }
            });
        }
    }
    getLatestPoints(tipCount) {
        let chain;
        if (tipCount >= this.chainSlotList.length) {
            chain = Array.from(this.chainSlotList);
        }
        else {
            chain = this.chainSlotList.slice(this.chainSlotList.length - tipCount - 1);
        }
        return chain.reverse().map(v => { return this.headerLookup.get(v)[0]; });
    }
    resolvePoint(point) {
        const lookup = this.headerLookup.get(point[0]);
        if (lookup) {
            if (lookup[0][1].compare(point[1]) == 0) {
                return [lookup[0], lookup[1]];
            }
        }
        else {
            const result = prisma.blockchain.findUnique({
                where: {
                    slotNo: point[0]
                }
            }).then(result => {
                if (result) {
                    return [[result.slotNo, result.headerHash], result.blockNo];
                }
            });
        }
        throw new Error('Method not implemented.');
    }
    getTip() {
        const result = this.headerLookup.get(this.chainSlotList[this.chainSlotList.length - 1]);
        if (result) {
            return [result[0], result[1]];
        }
        throw Error("Unexpected");
    }
    setBlockSource(source) {
        this.blockSource = source;
    }
    extend(headerData, highestPoint, callback) {
    }
    rollBack(rollbackPoint, latestTip, callback) {
        return false;
    }
    fetchHeaders(startBlock, count, callback) {
        const startPoint = this.chainSlotList[0];
        const chainLength = this.chainSlotList.length;
        const endPoint = this.chainSlotList[chainLength - 1];
        if (startBlock > endPoint) {
            setImmediate(callback);
        }
        else if (startBlock < endPoint) {
            // do fetch from database.
        }
        for (let i = chainLength - 1; i >= 0; i--) {
            if (this.chainSlotList[i] == startBlock) {
                const sliceEnd = i + count;
                const pointList = this.chainSlotList.slice(i, sliceEnd >= chainLength ? undefined : sliceEnd);
                const headerList = Array.from(pointList).map(x => {
                    return this.headerLookup.get(x);
                });
                setImmediate(() => { callback(headerList); });
            }
        }
    }
    rewrite(chain) {
    }
}
//# sourceMappingURL=SqlBlockchain.js.map