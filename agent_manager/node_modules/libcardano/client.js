"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InmemoryBlockchain_1 = require("./InmemoryBlockchain");
const network_1 = require("./network");
const protocol_1 = require("./protocol");
if (process.argv.length != 3) {
    console.error("Expected exactly 1 argument");
    process.exit(1);
}
const url = process.argv[2];
const peer = new network_1.NodePeer(url);
const blockChain = new InmemoryBlockchain_1.InmemoryBlockchain();
peer.onDisconnect = (err) => {
    function doConnect() {
        console.error("Connection terminated :" + (err === null || err === void 0 ? void 0 : err.message) || '');
        connect((err) => {
            if (err) {
                setTimeout(doConnect, 5000);
            }
        });
    }
    doConnect();
};
function connect(cb) {
    peer.connect((err) => {
        if (!err) {
            const handShakeProtocol = peer.createProtocolChannel(0);
            protocol_1.HandShake.initiate(handShakeProtocol, () => {
                // const txSubmissionChannel=peer.createProtocolChannel(4)!
                // TxSubmission.initiate(txSubmissionChannel)
                const keepAliveChannel = peer.createProtocolChannel(8);
                protocol_1.KeepAlive.initiate(keepAliveChannel);
                const blockFetchChannel = peer.createProtocolChannel(3);
                const blockFetch = new protocol_1.BlockFetch(blockFetchChannel);
                const chainSyncChannel = peer.createProtocolChannel(2);
                blockChain.setBlockSource((start, end, cb) => {
                    blockFetch.requestBlocks(start, end, {
                        onBlock(block) {
                            cb(block);
                        },
                        onComplete(start, end) {
                            console.log("BlockFetch complete");
                        },
                        onError(reason) {
                            console.log("BlockFetch: Unexpected error", reason);
                        }
                    });
                });
                protocol_1.ChainSync.initiate(chainSyncChannel, blockChain);
            }, 4);
        }
        else if (cb) {
            cb(err);
        }
        else {
            console.error(err);
        }
    });
}
connect();
//# sourceMappingURL=client.js.map