"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodePeer = void 0;
const net_1 = __importDefault(require("net"));
const cbor_1 = __importDefault(require("./lib/cbor"));
const defaultOptions = {
    logPackets: false
};
const nullFunction = (msg) => {
    console.warn("[WARN] Message ignored ", msg.payload ? msg.payload.toString('hex') : msg.toString());
};
const deaultErrHandler = (err) => { };
class NodePeer {
    constructor(connectionStr, initiated = true, peeroptions = defaultOptions) {
        // messageQueue for each protocol
        this.messageQueue = Array(12).fill([]);
        this.protocolDecoders = Array(12).fill(0).map(_val => cbor_1.default.createStreamDecoder());
        // message handler Functions 
        this.messageHandlers = Array(12).fill(nullFunction);
        this.rawHandler = (_) => { };
        // connection states 
        this.streamData = Buffer.alloc(0);
        this.onDisconnect = deaultErrHandler;
        this.peerOptions = peeroptions;
        this.connectionString = connectionStr;
        if (initiated) {
            this.roles = ["client", "server"];
            this.isInitiator = true;
        }
        else {
            this.roles = ["server", "client"];
            this.isInitiator = false;
        }
        this.protocolDecoders.forEach((decoder, index) => {
            decoder.on('data', (data) => {
                this.messageQueue[index].push(data);
                this.messageHandlers[index](data);
            });
        });
    }
    static createConnectOpt(connectionString) {
        let connectOpt;
        if (connectionString.startsWith('unix://')) {
            connectOpt = {
                path: connectionString.substring(7)
            };
        }
        else {
            const hostPort = connectionString.split(':');
            const port = hostPort.length > 1 ? (parseInt(hostPort[1]) || 3001) : 3001;
            connectOpt = {
                host: hostPort[0],
                port: port,
                timeout: 8
            };
        }
        return connectOpt;
    }
    createProtocolChannel(protocolId) {
        if (this.messageHandlers[protocolId] != nullFunction) {
            console.warn("Multiple  handler registration for  protocol no " + protocolId + " on peer:" + this.connectionString);
        }
        else {
            let handlerFunc = nullFunction;
            return {
                expectMessage: (handler) => {
                    handlerFunc = handler;
                    this.onNextMessage(protocolId, (msg) => {
                        handler(msg);
                    });
                },
                sendMessage: (message) => {
                    writeData(this.socket, this.isInitiator, protocolId, message, this.roles[0], this.peerOptions);
                }
            };
        }
    }
    setpIncomingMessageHandler() {
        const handleStreamData = (data) => {
            var _a;
            // merge pervious unUsed data
            this.streamData = Buffer.concat([this.streamData, data]);
            // check header size
            if (this.streamData.length > 8) {
                const header = decodeHeader(this.streamData);
                if (header.protocolId < 12) {
                    if (this.streamData.length >= (header.payloadLen + 8)) {
                        const payload = this.streamData.subarray(8, 8 + header.payloadLen);
                        if (this.peerOptions.logPackets) {
                            header.protocolId != 8 && console.log(((_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress) + " " + this.roles[1] + " : " + "timestamp=" + header.time + " miniProto=" + header.protocolId + " direction=" + header.direction + " payloadLen=" + header.payloadLen + " : " + payload.toString('hex'));
                        }
                        this.streamData = this.streamData.subarray(8 + header.payloadLen);
                        // pass on to the handlers
                        this.enqueMessage(header, payload);
                        if (this.streamData.length > 0) {
                            // try to process extra data.
                            handleStreamData(Buffer.from(""));
                        }
                    }
                }
                else {
                    this.header = header;
                    console.log(this.roles[1] + " :" + data.toString('hex'));
                }
            }
            else {
                console.log(this.roles[1] + " : " + data.toString('hex'));
            }
        };
        this.socket.on("data", (data) => {
            handleStreamData(data);
        });
    }
    connect(callback) {
        let socket;
        let connected = false;
        let err = null;
        this.messageHandlers = Array(12).fill(nullFunction);
        this.messageQueue = Array(12).fill([]);
        this.streamData = Buffer.alloc(0);
        console.log(`Attempting connection to: ${this.connectionString}`);
        this.socket = socket = net_1.default.connect(NodePeer.createConnectOpt(this.connectionString), () => {
            connected = true;
            callback();
        });
        // Handle socket errors
        socket.on('error', (error) => {
            err = error;
            if (!connected) {
                socket.end(() => { callback(error); });
            }
        });
        // Handle socket closure
        socket.on('close', () => {
            if (connected) {
                this.onDisconnect(err);
            }
            console.log(`Connection has been closed on the peer : ${this.connectionString}`);
        });
        this.setpIncomingMessageHandler();
    }
    // Internal function to insert message into proper bucket
    // according to protocol header.
    // This calls the registered message handler
    enqueMessage(header, payload) {
        if (header.protocolId >= this.protocolDecoders.length) {
            console.warn("Ignored message for protocolId:" + header.protocolId);
        }
        this.protocolDecoders[header.protocolId].write(payload);
    }
    // Install the handler for next message.
    // This replaces the default handler and installs the callback as the handler.
    // If the other end sends message without the onNextMessage called previously,
    // the message is discarded with warning.
    onNextMessage(protocolId, callback) {
        const messages = this.messageQueue[protocolId];
        if (messages.length > 0) {
            callback(messages.shift());
        }
        else {
            this.messageHandlers[protocolId] = () => {
                this.messageHandlers[protocolId] = nullFunction;
                callback(messages.shift());
            };
        }
    }
    static listen(address, port, onNewConnection) {
        // Create a TCP server
        const server = net_1.default.createServer((socket) => {
            console.log('Client connected', socket.remoteAddress);
            const peer = new NodePeer(socket.remoteAddress, false);
            peer.socket = socket;
            peer.setpIncomingMessageHandler();
            // Handle connection termination
            socket.on('end', () => {
                console.log('Client disconnected.');
            });
            socket.on('error', (err) => {
                console.log('Unexpected Error', err);
            });
            onNewConnection(peer);
        });
        // Bind the server to the specified address and port
        server.listen(port, address, () => {
            console.log(`Server listening on ${address}:${port}`);
        });
        server.on("error", (e) => {
            console.log("Server Error", e);
        });
    }
    static forward(listenAddress, destinationAddress, onMessage) {
        // Create a TCP server
        const dstOpt = NodePeer.createConnectOpt(destinationAddress);
        const listenOpt = NodePeer.createConnectOpt(listenAddress);
        function doForward(clientSock) {
            let connected = false;
            const serverSock = net_1.default.createConnection(dstOpt, () => {
                connected = true;
                console.log('Forwarding request ', (clientSock.remoteAddress || "") + ":" + (clientSock.remotePort || "") + " via ");
                const clientMux = createMuxHandler((header, payload) => {
                    onMessage("client", clientSock, header, payload);
                });
                const serverMux = createMuxHandler((header, payload) => {
                    onMessage("server", clientSock, header, payload);
                });
                clientSock.on('data', (data) => {
                    serverSock.write(data);
                    clientMux(data);
                });
                serverSock.on('data', data => {
                    clientSock.write(data);
                    serverMux(data);
                });
            });
            // Handle socket errors
            serverSock.on('error', (error) => {
                console.error('Socket error:', error);
                serverSock.end();
                clientSock.end();
            });
            // Handle socket closure
            serverSock.on('close', () => {
                console.log('Socket connection closed');
            });
            return serverSock;
        }
        const server = net_1.default.createServer((clientSock) => {
            console.log('Client connected', clientSock.remoteAddress);
            // Handle connection termination
            clientSock.on('end', () => {
                console.log('Client disconnected.');
            });
            clientSock.on('error', (err) => {
                console.log('Unexpected Error', err);
            });
            doForward(clientSock);
        });
        // Bind the server to the specified address and port
        server.listen(listenOpt, () => {
            console.log(`Forwarding from ` + JSON.stringify(listenOpt) + " to " + JSON.stringify(dstOpt));
        });
        server.on("error", (e) => {
            console.log("Server Error", e);
        });
    }
}
exports.NodePeer = NodePeer;
// Define the socket path (for Unix socket) or TCP host and port
// // Create a socket connection
function decodeHeader(buff) {
    const dirAndId = buff.readUInt16BE(4);
    return {
        time: buff.readUInt32BE(0),
        direction: dirAndId >> 15,
        protocolId: dirAndId & 0x7fff,
        payloadLen: buff.readUInt16BE(6),
    };
}
function writeHeader(buff, isInitiatorMode, protocolId, payloadLen) {
    buff.writeUint32BE(Math.trunc(Date.now() / 1000));
    const direction = isInitiatorMode ? 0 : 1;
    buff.writeUint16BE((direction << 15) | protocolId, 4);
    buff.writeUInt16BE(payloadLen, 6);
}
function writeDataRaw(socket, isInitiatorMode, protocolId, message, role = 'client', peerOption) {
    const header = Buffer.alloc(8);
    writeHeader(header, isInitiatorMode, protocolId, message.length);
    if (peerOption.logPackets) {
        console.log(socket.remoteAddress + " " + role + " : " + "timestamp=" + header.readUInt32BE() + " miniProto=" + protocolId + " direction=" + (isInitiatorMode ? 0 : 1) + " payloadLen=" + message.length + " : " + message.toString('hex'));
    }
    socket.write(Buffer.concat([header, message]));
}
function writeData(socket, isInitiatorMode, protocolId, data, role = 'client', peerOption) {
    writeDataRaw(socket, isInitiatorMode, protocolId, cbor_1.default.encode(data), role, peerOption);
}
function createMuxHandler(onMessage) {
    let streamData = Buffer.from("");
    let lastHeader;
    const handleStreamData = (data) => {
        // merge pervious unUsed data
        streamData = Buffer.concat([streamData, data]);
        // check header size
        if (streamData.length > 8) {
            const header = lastHeader || decodeHeader(streamData);
            if (streamData.length >= header.payloadLen + 8) {
                const payload = streamData.subarray(8, 8 + header.payloadLen);
                streamData = streamData.subarray(8 + header.payloadLen);
                // pass on to the handlers
                onMessage(header, payload);
                lastHeader = undefined;
                if (streamData.length > 0) {
                    // try to process extra data.
                    handleStreamData(Buffer.from(""));
                }
            }
            else {
                lastHeader = header;
            }
        }
    };
    return handleStreamData;
}
//# sourceMappingURL=network.js.map