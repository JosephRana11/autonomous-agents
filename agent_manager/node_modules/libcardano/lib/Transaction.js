"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cbor = __importStar(require("cbor"));
const cbor_1 = require("cbor");
const bech32_1 = require("bech32");
class Transaction {
    constructor(tx, source) {
        this.source = source;
        const inputs = tx[0].get(0).map((input) => {
            return {
                hash: input[0].toString('hex'),
                index: input[1]
            };
        });
        const outputs = this.getOutput(tx[0].get(1));
        let mintTokens;
        if (tx[0].has(9)) {
            mintTokens = this.assetMapParse(tx[0].get(9));
        }
        let metadata = null;
        if (tx[3] != null) {
            if (tx[3] instanceof cbor_1.Tagged) {
                metadata = tx[3].toJSON();
            }
            else {
                metadata = tx[3];
            }
        }
        this.inputs = inputs;
        this.outputs = outputs;
        this.mint = mintTokens;
        this.metadata = metadata;
    }
    assetMapParse(assetMap) {
        return Array.from(assetMap).map((arr) => {
            const currSymbol = arr[0].toString('hex');
            const val = arr[1];
            const numberOfAsset = Array.from(val).map((item) => {
                const assetId = item[0], amount = item[1];
                const assetIdHex = assetId.toString('hex');
                return {
                    assetIdHex,
                    amount
                };
            });
            return {
                currSymbol,
                numberOfAsset
            };
        });
    }
    parseMultiAsset(value) {
        if (Array.isArray(value)) {
            const multiAssets = this.assetMapParse(value[1]);
            const assets = [{ 'lovelace': value[0] }, ...multiAssets];
            return assets;
        }
        else {
            return [{ 'lovelace': value }];
        }
    }
    getOutput(outputs) {
        return outputs.map((output) => {
            if (Array.isArray(output)) {
                const assets = this.parseMultiAsset(output[1]);
                let datumHash = null;
                if (output.length > 2) {
                    datumHash = output[2];
                }
                return {
                    "address": bech32_1.bech32.encode('addr_test', bech32_1.bech32.toWords(output[0]), 150),
                    "amount": assets,
                    "datumHash": datumHash
                };
            }
            else {
                return {
                    "address": bech32_1.bech32.encode('addr_test', bech32_1.bech32.toWords(output.get(0)), 150),
                    "amount": this.parseMultiAsset(output.get(1)),
                };
            }
        });
    }
    to_bytes() {
        return this.source;
    }
    static from_bytes(bytes) {
        return new Transaction(cbor.decodeFirstSync(bytes), bytes);
    }
    static unsafe_from_decoded(json) {
        return new Transaction(json, Buffer.from(''));
    }
}
module.exports = Transaction;
//# sourceMappingURL=Transaction.js.map