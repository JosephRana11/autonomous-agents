"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockFetch = exports.TxSubmission = exports.KeepAlive = exports.HandShake = exports.ChainSync = void 0;
class OuroborosProtocol {
    constructor(channel) {
        this.channel = channel;
    }
    sendMessage(msg) {
        this.channel.sendMessage;
    }
}
class ChainSync {
    constructor(channel, blockchain) {
        this.lastState = 0;
        this.channel = channel;
        this.blockchain = blockchain;
    }
    static initiate(channel, blockchain) {
        const chainSync = new ChainSync(channel, blockchain);
        const points = blockchain.getLatestPoints(10);
        // start from genesis if not present
        // @ts-ignore
        chainSync.sendFindIntersect(points.length > 0 ? points : [[]]);
        // chainSync.sendRequestNext()
        chainSync.expectNextMessage();
    }
    expectNextMessage() {
        this.channel.expectMessage((msg) => {
            this.serverMessageReceived(msg);
        });
    }
    static listen(channel, blockchain) {
        let currentPoint;
        let synced = false;
        let headerList = [];
        let blocked = false;
        function subscribeChain() {
            blockchain.on('extendHeader', (event) => {
                if (blocked) {
                    currentPoint = [[event.slotNo, event.headerHash], event.blockNo];
                    channel.sendMessage([2, event.header, event.chainTip]);
                    channel.expectMessage(handler);
                    blocked = false;
                }
                else {
                    headerList.push([[event.slotNo, event.headerHash], event.blockNo, event.header]);
                }
            }),
                blockchain.on("rollback", (point, tip) => {
                    if (blocked) {
                        currentPoint = point;
                        channel.sendMessage([3, point, tip]);
                        blocked = false;
                        channel.expectMessage(handler);
                    }
                    else {
                        for (let i = headerList.length; i >= 0; i--) {
                            if (headerList[i][1] == point[1]) {
                                headerList.splice(i);
                                return; // nothing else to do
                            }
                        }
                        console.warn("Rollback received when client is not in blocked sate");
                        // TODO: notify the client about rollback being too deep
                    }
                });
        }
        const enterBlockedState = () => { channel.sendMessage([1]); blocked = true; };
        const handler = (msg) => {
            switch (msg[0]) {
                case 0: // requestNext
                    let header = headerList.shift();
                    if (header) {
                        currentPoint = header.slice(0, 1);
                        channel.sendMessage([2, header, blockchain.getTip()]);
                        channel.expectMessage(handler);
                    }
                    else {
                        enterBlockedState();
                    }
                    break;
                case 4: // find intersect
                    // received 
                    const clientChain = msg[1];
                    const preSyncHandler = (msg) => {
                        const tip = blockchain.getTip();
                        if (currentPoint[1] == tip[1]) { // synced.
                            subscribeChain();
                            console.log("Client is synced with us: Subscribing chain events.");
                            enterBlockedState();
                        }
                        else {
                            let header = headerList.shift();
                            if (header) {
                                currentPoint = header.slice(0, 1);
                                channel.sendMessage([2, header, tip]);
                                channel.expectMessage(preSyncHandler);
                            }
                            else {
                                blockchain.fetchHeaders(currentPoint[1] + 1, 10, (newList) => {
                                    if (newList) {
                                        headerList = newList;
                                        header = headerList.shift();
                                        currentPoint = header.slice(0, 1);
                                        channel.sendMessage([2, header, tip]);
                                        channel.expectMessage(preSyncHandler);
                                    }
                                });
                            }
                        }
                    };
                    if (clientChain.length > 0) {
                        blockchain.intersect(clientChain, (resolvedPoint) => {
                            if (resolvedPoint) {
                                // say to the client that we are at the same chain height as them.
                                channel.sendMessage([5, resolvedPoint[0], resolvedPoint]);
                                currentPoint = resolvedPoint;
                                channel.expectMessage(() => {
                                    currentPoint = resolvedPoint;
                                    // the first message must be rollback, as it seems.
                                    channel.sendMessage([3, resolvedPoint[0], blockchain.getTip()]);
                                    channel.expectMessage(preSyncHandler);
                                    // at the start we need to send the rollback to the same point for some stupid reason.
                                });
                            }
                            else {
                                channel.sendMessage([6, blockchain.getTip()]);
                                channel.expectMessage(handler);
                            }
                        });
                    }
                    else {
                        // intersection not found
                        const tip = blockchain.getTip();
                        channel.sendMessage([6, tip]);
                        channel.expectMessage(handler);
                        // channel.sendMessage([6,[[1,Buffer.from("02c4a834959d5a73403ee8d0b24c440af23d169c525479f155a748fe91ffb30f","hex")],1]])
                    }
                    break;
                default:
                    enterBlockedState();
            }
        };
        channel.expectMessage(handler);
    }
    serverMessageReceived(msg) {
        switch (msg[0]) {
            case 1: // await (We are synced.)
                // we wait for server to send message
                this.expectNextMessage();
                break;
            case 2: // rollForward
                this.blockchain.extend(msg[1], msg[2], (err) => {
                    this.sendRequestNext();
                    this.expectNextMessage();
                });
                break;
            case 3: // rollBackward
                this.blockchain.rollBack(msg[1], msg[2], (err) => {
                    if (err) {
                        console.error("[Error]", "Local Chain Couldn't handle rollback", err);
                    }
                    this.sendRequestNext();
                    this.expectNextMessage();
                });
                break;
            case 5: // intersection found
                this.sendRequestNext();
                this.expectNextMessage();
                break;
            case 6: // intersection not found
                // this.sendMsgDone()
                console.error("ChainSync: Failed to find intersection: Node is at slot:", msg[1][0][0], "bockHash=", msg[1][0][1].toString('hex'), "blockNo=", msg[1][1]);
                // this.blockchain.reWrite([msg[1]]) // reset blockchain to the server's tip
                this.sendFindIntersect([msg[1][0]]);
                this.expectNextMessage();
        }
    }
    sendRequestNext() {
        this.channel.sendMessage([0]);
    }
    sendAwait() {
        this.channel.sendMessage([1]);
    }
    sendMsgIntersectFound(chainPoint, chainTip) {
        this.lastState = 5;
        this.channel.sendMessage([5, chainPoint, chainTip]);
    }
    sendRollForward(chainTip, header) {
        this.lastState = 2;
        this.channel.sendMessage([2, header, chainTip]);
    }
    sendRollBackward(chainPoint, chainTip) {
        this.lastState = 3;
        this.channel.sendMessage([3, chainPoint, chainTip]);
    }
    sendFindIntersect(points) {
        this.lastState = 4;
        this.channel.sendMessage([4, points]);
    }
    sendIntersectNotFound(tip) {
        this.lastState = 6;
        this.channel.sendMessage([6, tip]);
    }
    sendMsgDone() {
        this.lastState = 7;
        this.channel.sendMessage([7]);
    }
}
exports.ChainSync = ChainSync;
class HandShake {
    static initiate(channel, callback, network = 2) {
        const protocolMap = new Map();
        protocolMap.set(9, [network, true]);
        protocolMap.set(10, [network, true]);
        // protocolMap.set(11,[network,true,2,0])
        channel.sendMessage([0, protocolMap]);
        channel.expectMessage((msg) => {
            console.log(msg);
            if (msg[1][0] == 2) {
                console.error("HandShakeError : " + msg[1][2]);
            }
            else {
                callback();
            }
            // we ignore the message.
        });
    }
    static accept(channel, callback) {
        channel.expectMessage((msg) => {
            //[1, 10, [1, true]]
            const protocols = msg[1];
            let reply;
            if (protocols.has(10)) {
                reply = [1, 10, protocols.get(10)];
            }
            else if (protocols.has(9)) {
                reply = [1, 9, protocols.get(9)];
            }
            else if (protocols.has(8)) {
                reply = [1, 8, protocols.get(8)];
            }
            if (reply) {
                channel.sendMessage(reply);
                callback(true);
            }
            else {
                channel.sendMessage([2, [2, 7, "Some undefined error"]]);
                callback(false);
            }
        });
    }
}
exports.HandShake = HandShake;
class PingData {
    constructor(data) {
        this.data = data;
    }
    encodeCBOR(encoder) {
        return encoder.pushAny(this.data || (Math.trunc(Math.random() * 2000)));
    }
}
const pingMessage = [0, new PingData()];
class KeepAlive {
    static initiate(channel) {
        channel.sendMessage(pingMessage);
        channel.expectMessage((pong) => {
            setTimeout(() => {
                this.initiate(channel);
            }, 10000);
        });
    }
    static listen(channel) {
        const handler = (ping) => {
            channel.sendMessage([1, ping[1]]);
            channel.expectMessage(handler);
        };
        channel.expectMessage(handler);
    }
}
exports.KeepAlive = KeepAlive;
class TxSubmission {
    // THIS is not correct implementation for initiate. It's just here.
    static initiate(channel) {
        channel.sendMessage([6]);
        channel.expectMessage(msg => {
            console.log("TxSubmission initated with reply:", msg);
        });
    }
    static listen(channel) {
        const handler = (message) => {
            switch (message[0]) {
                case 6: // Tx Submission initialization request
                    channel.sendMessage([0, true, 0, 3]); // wait for me to send the transaction ;) , but we won't forward any unsubmited transactions.
                    channel.expectMessage(handler);
                    break;
                case 1:
                    const transactions = message[1];
                    console.log("TxSubmit", transactions.map(v => v[0][1].toString('hex')));
                    channel.sendMessage([0, true, 1, 3]);
                    channel.expectMessage(handler);
                    break;
                default:
                    console.log("Unexpected TxSubmission Request", message);
            }
        };
        channel.expectMessage(handler);
    }
}
exports.TxSubmission = TxSubmission;
var BlockFetchState;
(function (BlockFetchState) {
    BlockFetchState[BlockFetchState["Idle"] = 0] = "Idle";
    BlockFetchState[BlockFetchState["RequestSent"] = 1] = "RequestSent";
    BlockFetchState[BlockFetchState["Downloading"] = 2] = "Downloading";
    BlockFetchState[BlockFetchState["Error"] = 3] = "Error";
})(BlockFetchState || (BlockFetchState = {}));
class BlockFetch {
    constructor(channel, state = BlockFetchState.Idle) {
        this.channel = channel;
        this.state = state;
    }
    requestBlocks(start, _endpoint = null, callback) {
        let endpoint = _endpoint || start;
        this.channel.sendMessage([0, start, endpoint]);
        this.state = BlockFetchState.RequestSent;
        let block = null;
        const handler = (msg) => {
            switch (msg[0]) {
                case 1: // msgDone
                    this.state = BlockFetchState.Idle;
                    callback.onComplete(start, endpoint);
                    break;
                case 2: // msgStartBatch
                    this.state = BlockFetchState.Downloading;
                    break;
                case 3: // msgNoBlocks
                    this.state = BlockFetchState.Error;
                    callback.onError("Server replied: NoBlocks");
                    break;
                case 4: // msgBlock
                    block = msg[1];
                    break;
                case 5:
                    this.state = BlockFetchState.Idle;
                    callback.onBlock(block.value);
                    break;
                default:
                    callback.onError("Server malfunctioned");
                    this.state = BlockFetchState.Error;
            }
            this.channel.expectMessage(handler);
        };
        this.channel.expectMessage(handler);
    }
    _processMessage(msg) {
    }
    // 16 msgRequestRange = [0 , point , p o in t ]
    // 17 msgClientDone = [ 1 ]
    // 18 msgStartBatch = [ 2 ]
    // 19 msgNoBlocks = [ 3 ]
    // 20 msgBlock = [4 , block ]
    // 21 msgBatchDone = [ 5 ]
    static listen(channel) {
        const handler = (message) => {
            switch (message[0]) {
                case 6: // Tx Submission initialization request
                    channel.sendMessage([0, true, 0, 3]); // wait for me to send the transaction ;) , but we won't forward any unsubmited transactions.
                    channel.expectMessage(handler);
                    break;
                case 1:
                    const transactions = message[1];
                    console.log("TxSubmit", transactions.map(v => v[0][1].toString('hex')));
                    channel.sendMessage([0, true, 1, 3]);
                    channel.expectMessage(handler);
                    break;
                default:
                    console.log("Unexpected TxSubmission Request", message);
            }
        };
        channel.expectMessage(handler);
    }
}
exports.BlockFetch = BlockFetch;
//# sourceMappingURL=protocol.js.map