"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("@cardano-sdk/crypto");
const bech32_1 = require("bech32");
const bip39_1 = require("bip39");
const KEYHASH_LENGTH = 28;
const ADDR_LENGTH = KEYHASH_LENGTH * 2 + 1;
const harden = (num) => {
    return 0x80000000 + num;
};
function derivationsFromAccountKey(accountKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const paymentKey = (yield accountKey.derive([0, 0])).toRawKey();
        const stakekey = (yield accountKey.derive([2, 0])).toRawKey();
        const drepKey = (yield accountKey.derive([3, 0])).toRawKey();
        return { paymentKey, stakekey, drepKey };
    });
}
function toRawBytes(network, paymentKeyHash, stakeKeyHash) {
    const rawBytes = new Uint8Array(ADDR_LENGTH);
    rawBytes[0] = network;
    rawBytes.set(paymentKeyHash, 1);
    rawBytes.set(stakeKeyHash, KEYHASH_LENGTH + 1);
    return rawBytes;
}
function toBech32(network, paymentKeyHash, stakeKeyHash) {
    const prefix = network == 0 ? "addr_test" : "addr";
    return bech32_1.bech32.encode(prefix, bech32_1.bech32.toWords(toRawBytes(network, paymentKeyHash, stakeKeyHash)), 200);
}
function deriveAddress(network, mnemonic, accountIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        const entropy = (0, bip39_1.mnemonicToEntropy)(mnemonic);
        const rootKeyPair = yield crypto_1.Bip32PrivateKey.fromBip39Entropy(Buffer.from(entropy, 'hex'), '');
        const accountKey = yield rootKeyPair.derive([harden(1852), harden(1815), harden(accountIndex)]);
        const { paymentKey, stakekey, drepKey } = yield derivationsFromAccountKey(accountKey);
        const paymentPublickey = yield (yield paymentKey.toPublic()).hash();
        const stakePublicKey = yield (yield stakekey.toPublic()).hash();
        const bech32Address = toBech32(network, paymentPublickey.bytes(), stakePublicKey.bytes());
        console.log("account " + accountIndex + " :", bech32Address);
        return bech32Address;
    });
}
const seed = 'midnight draft salt dirt woman tragic cause immense dad later jaguar finger nerve nerve sign job erase citizen cube neglect token bracket orient narrow';
deriveAddress(0, seed, 0);
deriveAddress(0, seed, 1);
deriveAddress(0, seed, 2);
deriveAddress(0, seed, 3);
//# sourceMappingURL=hdKeys.js.map