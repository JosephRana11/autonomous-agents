"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.install_db_subscriber = exports.rollback = exports.rollForward = exports.saveBlock = exports.saveBlockHeader = void 0;
const runtime_1 = require("@prisma/client/runtime");
const client_1 = require("@prisma/client");
const prisma = new client_1.PrismaClient();
let isExiting = false;
// Gracefully handle process termination
process.on('SIGINT', () => __awaiter(void 0, void 0, void 0, function* () {
    // Check if the process is already exiting
    if (isExiting) {
        return;
    }
    isExiting = true;
    console.log('\nStopping application...');
    try {
        // Disconnect from the Prisma database
        yield prisma.$disconnect();
        console.log('Prisma disconnected.');
    }
    catch (e) {
        console.error('Error disconnecting from Prisma:', e);
    }
    finally {
        // Exit the process
        process.exit();
    }
}));
function saveBlockHeader(hash, headerData, cb = () => { }) {
    return prisma.blocks.create({
        data: {
            headerHash: hash,
            header: headerData
        }
    }).catch(e => {
        console.error("Unexpected error saving block " + hash);
    });
}
exports.saveBlockHeader = saveBlockHeader;
function saveBlock(hash, blockBody) {
    return __awaiter(this, void 0, void 0, function* () {
        return prisma.blocks.update({
            where: {
                headerHash: hash
            },
            data: {
                body: blockBody
            }
        });
    });
}
exports.saveBlock = saveBlock;
function rollForward(tip) {
    return __awaiter(this, void 0, void 0, function* () {
        return prisma.blockchain.create({
            data: {
                blockNo: tip[1],
                slotNo: tip[0][0],
                headerHash: tip[0][1]
            }
        }).catch((e) => {
            if (e instanceof runtime_1.PrismaClientKnownRequestError) {
                console.error(e);
            }
            throw e;
        });
    });
}
exports.rollForward = rollForward;
function rollback(tip) {
    return __awaiter(this, void 0, void 0, function* () {
        return prisma.blockchain.deleteMany({
            where: {
                slotNo: {
                    gt: tip[0]
                }
            }
        });
    });
}
exports.rollback = rollback;
function install_db_subscriber(blockchain) {
    return __awaiter(this, void 0, void 0, function* () {
        return prisma.$connect().then(() => __awaiter(this, void 0, void 0, function* () {
            console.log("Database opened");
            const chainQuery = yield prisma.blockchain.findMany({
                orderBy: {
                    slotNo: 'desc'
                },
                take: 1000,
                select: {
                    block: {
                        select: {
                            body: true
                        }
                    }
                }
            });
            const chain = chainQuery.map(v => v.block.body);
            blockchain.rewrite(chain.reverse());
            blockchain.pipeline('rollback', (to, head, cb) => {
                console.log("Handling rollback");
                rollback(to[0]).then(() => cb()).catch(cb);
            });
            blockchain.pipeline('extendBlock', (event, cb) => {
                const action = () => __awaiter(this, void 0, void 0, function* () {
                    let dbBlock = yield prisma.blocks.findFirst({
                        "where": {
                            headerHash: event.headerHash
                        }, select: {
                            header: true
                        }
                    });
                    if (!dbBlock) {
                        dbBlock = yield prisma.blocks.create({
                            data: {
                                header: event.header,
                                headerHash: event.headerHash,
                                body: event.body
                            }
                        });
                    }
                    yield rollForward([[event.slotNo, event.headerHash], event.blockNo]);
                    return dbBlock;
                });
                action().then(() => cb()).catch(e => {
                    if (e) {
                        cb(e);
                    }
                    else {
                        cb(new Error("UnknownError Saving block to chain"));
                    }
                });
            });
        }));
    });
}
exports.install_db_subscriber = install_db_subscriber;
//# sourceMappingURL=sql.js.map