"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InmemoryBlockchain_1 = require("./InmemoryBlockchain");
const network_1 = require("./network");
const protocol_1 = require("./protocol");
const sql_1 = require("./persistence/sql");
const blockchain = new InmemoryBlockchain_1.InmemoryBlockchain();
const url = process.argv[2] || '172.31.0.6:3004';
const peer = new network_1.NodePeer(url);
(0, sql_1.install_db_subscriber)(blockchain).then(() => {
    // install_kafka_subscriber(blockchain)
    peer.connect((err) => {
        if (!err) {
            const handShakeProtocol = peer.createProtocolChannel(0);
            protocol_1.HandShake.initiate(handShakeProtocol, () => {
                // persistance.subscribe(blockchain,{
                //   fetchBlock(hash:Buffer){
                //     console.warn("[WARN] ignoring block fetch request:",hash.toString('hex'))
                //   }
                // })
                let listening;
                listening = () => {
                    startServer();
                    blockchain.unsubscribe("extendBlock", listening);
                };
                blockchain.on("extendBlock", listening);
                const txSubmissionChannel = peer.createProtocolChannel(4);
                protocol_1.TxSubmission.initiate(txSubmissionChannel);
                // const keepAliveChannel=peer.createProtocolChannel(8)!
                // KeepAlive.initiate(keepAliveChannel)
                const chainSyncChannel = peer.createProtocolChannel(2);
                protocol_1.ChainSync.initiate(chainSyncChannel, blockchain);
                const blockFetchChannel = peer.createProtocolChannel(3);
                const blockFetch = new protocol_1.BlockFetch(blockFetchChannel);
                blockchain.setBlockSource((start, end, cb) => {
                    blockFetch.requestBlocks(start, end, {
                        onBlock(block) {
                            cb(block);
                        },
                        onComplete(start, end) {
                            console.log("BlockFetch complete");
                        },
                        onError(reason) {
                            console.log("BlockFetch: Unexpected error", reason);
                        }
                    });
                });
            }, 4);
        }
    });
});
// connect to a peer, perform handshake and then start server functionality 
function startServer() {
    network_1.NodePeer.listen('0.0.0.0', 3004, peer => {
        const handshakeChannel = peer.createProtocolChannel(0);
        protocol_1.HandShake.accept(handshakeChannel, (success) => {
            if (success) {
                const txSubmissionChannel = peer.createProtocolChannel(4);
                protocol_1.TxSubmission.listen(txSubmissionChannel);
                const keepAliveChannel = peer.createProtocolChannel(8);
                protocol_1.KeepAlive.listen(keepAliveChannel);
                const chainSyncChannel = peer.createProtocolChannel(2);
                protocol_1.ChainSync.listen(chainSyncChannel, blockchain);
            }
        });
    });
}
//# sourceMappingURL=cardano-node.js.map