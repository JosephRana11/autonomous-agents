"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InmemoryBlockchain = void 0;
const cbor_1 = require("cbor");
const cbor_2 = __importDefault(require("cbor"));
const blake2b_1 = __importDefault(require("blake2b"));
const blockchain_1 = require("./blockchain");
class InmemoryBlockchain extends blockchain_1.BlockChainBase {
    constructor() {
        super();
        this.blockchain = [];
        this.blocks = new Map();
        this.headers = new Map();
        this.options = {
            logChainSync: false
        };
    }
    unsubscribe(event, handler) {
        const subscriberList = this.subscribers[event];
        for (let i = 0; i < subscriberList.length; i++) {
            if (subscriberList[i] == handler) {
                subscriberList.splice(i, 1);
            }
        }
    }
    intersect(points, callback) {
        // find the intersection between current chain and this chain (this chain is assumed to be ascending)    
        let index = 0;
        let ownSlot = this.blockchain[0][0][0];
        let foreignSlot = points[0][0];
        let chainSize, targetSlot;
        let getPoint;
        // this being untrue means 
        // we are out of sync compared to the client.  or client is requesting for non-existing chain.
        if (ownSlot <= foreignSlot) {
            chainSize = this.blockchain.length;
            getPoint = (i) => this.blockchain[i];
            targetSlot = foreignSlot;
            let slotNo = ownSlot;
            while (slotNo < targetSlot && index < chainSize) {
                slotNo = getPoint(index)[0][0];
                index++;
            }
            if (index !== chainSize && slotNo == targetSlot) {
                if (this.blockchain[index][0][1].compare(points[0][1]) == 0) {
                    callback(getPoint(index));
                    return;
                }
                else if (index > 0) {
                    callback(getPoint(index - 1));
                    return;
                }
            }
        }
        callback();
    }
    // returns last tipCount chain points in descending order
    getLatestPoints(tipCount) {
        let chain;
        if (tipCount >= this.blockchain.length) {
            chain = Array.from(this.blockchain);
        }
        else {
            chain = this.blockchain.slice(this.blockchain.length - tipCount - 1);
        }
        return chain.reverse().map(v => v[0]);
    }
    resolvePoint(point, callback) {
        const length = this.blockchain.length;
        for (let i = 0; i < length; i++) {
            if (this.blockchain[i][0][0] == point[0]) {
                setImmediate(() => callback(this.blockchain[i]));
                return;
            }
        }
        setImmediate(callback);
    }
    getTip() {
        return this.blockchain[this.blockchain.length - 1];
    }
    setBlockSource(source) {
        this.blockSource = source;
    }
    extend(headerData, highestPoint, callback) {
        const heaverVersion = headerData[0];
        const serialisedHeader = headerData[1].value;
        const headerHash = Buffer.from((0, blake2b_1.default)(32).update(serialisedHeader).digest('binary'));
        const decodedHeader = (0, cbor_1.decodeFirstSync)(serialisedHeader);
        const blockNo = decodedHeader[0][0];
        const slotNo = decodedHeader[0][1];
        const headerHashLast = decodedHeader[0][2];
        this.headers.set(headerHash, headerData);
        if (this.options.logChainSync)
            console.log("Roll Forward:", "blockNo=", blockNo, "slotNo=", slotNo, "prevBlock=", headerHashLast === null || headerHashLast === void 0 ? void 0 : headerHashLast.toString('hex'), "newBlock=", headerHash.toString('hex'));
        this.blockchain.push([[slotNo, Buffer.from(headerHash)], blockNo]);
        if (this.blockchain.length > 1000) {
            this.blockchain.unshift();
        }
        const currentTip = this.getTip();
        const headerEvent = {
            headerHash, slotNo, blockNo, header: cbor_2.default.encodeOne(headerData), chainTip: currentTip
        };
        this.notifyEvent('extendHeader', (err1) => {
            if (err1) {
                console.error("Couldn't extend blockchain header", err1);
                callback(err1);
            }
            else if (this.blockSource) {
                this.blockSource([slotNo, headerHash], [slotNo, headerHash], (block) => {
                    this.blocks.set(headerHash, block);
                    this.notifyEvent('extendBlock', (err2) => {
                        if (err2) {
                            console.error("Couldn't extend blockchain block", err2);
                            setImmediate(callback, err2);
                        }
                        else {
                            setImmediate(callback);
                        }
                    }, Object.assign(Object.assign({}, headerEvent), { body: block }));
                });
            }
            else {
                console.warn("No handler for block fetch protocol");
                setImmediate(callback, new Error("No Block Sources available."));
            }
        }, headerEvent);
    }
    rollBack(rollbackPoint, latestTip, callback) {
        // @ts-ignore Rollback to genesis
        if (rollbackPoint.length == 0) {
            this.blockchain = [];
            this.headers = new Map();
            this.blocks = new Map();
            setImmediate(callback);
            return true;
        }
        if (this.options.logChainSync)
            console.log("Roll Back:", "slot=", rollbackPoint[0], "block=", rollbackPoint[1].toString('hex'));
        for (let i = this.blockchain.length - 1; i >= 0; i--) {
            const point = this.blockchain[i];
            if (point[0][0] == rollbackPoint[0] && point[0][1].compare(rollbackPoint[1]) == 0) {
                this.blockchain.splice(i);
                this.notifyEvent('rollback', () => {
                    setImmediate(callback);
                }, point, this.getTip());
                return true;
            }
        }
        setImmediate(callback);
        return false;
    }
    rewrite(chain) {
        chain.forEach(data => {
            const block = cbor_2.default.decode(data);
            const header = block[1][0];
            const serialisedHeader = cbor_2.default.encodeOne(header);
            const headerHash = Buffer.from((0, blake2b_1.default)(32).update(serialisedHeader).digest('binary'));
            const blockNo = header[0][0];
            const slotNo = header[0][1];
            const headerHashLast = header[0][2];
            this.blockchain.push([[slotNo, headerHash], blockNo]);
            this.blocks.set(headerHash, block);
            this.headers.set(headerHash, serialisedHeader);
        });
        console.log(`[Load in-memory] loaded ${chain.length} blocks from db`);
    }
    fetchHeaders(startBlock, count, callback) {
        const startPoint = this.blockchain[0];
        const chainLength = this.blockchain.length;
        const endPoint = this.blockchain[chainLength - 1];
        if (startBlock > endPoint[1] || startBlock < startPoint[1]) {
            setImmediate(callback);
        }
        for (let i = chainLength - 1; i >= 0; i--) {
            if (this.blockchain[i][1] == startBlock) {
                const sliceEnd = i + count;
                const pointList = this.blockchain.slice(i, sliceEnd >= chainLength ? undefined : sliceEnd);
                const headerList = Array.from(pointList).map(x => {
                    return [x[0], x[1], this.headers.get(x[0][1])];
                });
                setImmediate(() => { callback(headerList); });
            }
        }
    }
}
exports.InmemoryBlockchain = InmemoryBlockchain;
//# sourceMappingURL=InmemoryBlockchain.js.map